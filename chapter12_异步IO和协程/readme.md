<!--
 * @Author: WangHao
 * @Date: 2020-01-10 22:18:29
 * @LastEditors  : WangHao
 * @LastEditTime : 2020-01-11 15:08:18
 * @Description: None
 -->
__并发并行__：

并发指在一个时间段内，有几个程序在用一个CPU上运行，但是任意时刻只有一个程序在CPU上运行。

并行是指任意时刻点上，有多个程序同时运行在多个CPU上。　　
并行和CPU数是一致的，CPU4核最多4个程序并行。


__select__:

是阻塞式的，会等待线程IO完成之后再进行下一步操作  
但是select可以同时监听很多个线程，如果其中一个线程IO完成可以立即执行下一步操作  
apache服务器采用的是这种方式  
select的IO多路复用省掉的是等待数据的部分，将数据从内核复制到用户空间的过程是省不掉的。  

单个进程能够监视的文件描述符有最大限制，Linux一般为1024，但是可以通过修改宏定义甚至重新编译内核在提示限制，但也会造成效率低。

select会遍历所有的fdset，所以效率会低。

__poll__：

没有最大数量限制，与select一样的是poll返回后需要轮询poolfd来获取就绪的描述符。

__epoll__：

在linux下支持，windows不支持。  

没有描述符限制，使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个时间表中，这样在用户空间和内核空间只需要copy一次。

epoll的查询使用到了红黑树。

nginx使用epoll

__信号驱动式IO__：



__异步IO__：

aio，对IO多路复用性能提升不是很高，所以还是使用io多路复用较多。  


__select, pool, epool__：

都是IO多路复用技术，就是用过一种技术，一个进程可以监视多个描述符，一旦某个描述符就绪，就能通知程序进行相应的读写操作。但select， poll，epoll本质上都是同步IO，因为他们都需要在读写事件就绪之后自己负责读写，也就是说这个读写过程是阻塞的，而异步IO无需自己读写，异步IO的实现会负责把数据从内核拷贝到用户空间。

select:  
